syntax = "proto3";

package tunn.v1;

option go_package = "github.com/behrlich/tunn/pkg/proto/tunnelv1";

// TunnelService manages the control plane for reverse tunnels between
// the tunn proxy server and tunn serve clients.
service TunnelService {
  // EstablishTunnel creates a bidirectional stream for tunnel control.
  // The client initiates the stream and sends a RegisterClient message.
  // The server sends ProxyRequest messages when new connections need to be forwarded.
  // Both sides can send HealthCheck messages to keep the connection alive.
  rpc EstablishTunnel(stream TunnelMessage) returns (stream TunnelMessage);
}

// TunnelMessage is the envelope for all control plane and data plane messages.
// This allows multiple message types to be sent over a single bidirectional stream.
message TunnelMessage {
  oneof message {
    RegisterClient register_client = 1;
    RegisterResponse register_response = 2;
    ProxyRequest proxy_request = 3;
    ProxyResponse proxy_response = 4;
    HealthCheck health_check = 5;
    HealthCheckResponse health_check_response = 6;
    HttpRequest http_request = 7;
    HttpResponse http_response = 8;
    StreamClosed stream_closed = 9;
    UdpPacket udp_packet = 10;
  }
}

// RegisterClient is sent by the client (tunn serve) when it first connects
// to register a new tunnel with the proxy server.
message RegisterClient {
  // tunnel_id is a unique identifier for this tunnel (can be generated client-side)
  string tunnel_id = 1;
  // target_url is the local service to forward requests to (e.g., "http://localhost:8000")
  string target_url = 2;
  // auth_token is the JWT from `tunn login` (contains creator's email)
  string auth_token = 3;
  // creator_email is extracted from the JWT (email of tunnel creator)
  string creator_email = 4;
  // allowed_emails is the list of emails that can access this tunnel (Google Doc model)
  // The creator_email is automatically included
  repeated string allowed_emails = 5;
  // tunnel_key is the secret that allows creating tunnels
  // V1: WELL_KNOWN_KEY (free for everyone)
  // V2: Remove this, check subscription via tunn-auth instead
  string tunnel_key = 6;
  // protocol specifies what protocol this tunnel supports: "http", "udp", or "both"
  // Default: "http" for backwards compatibility
  string protocol = 7;
  // udp_target_address is the local UDP service to forward packets to (e.g., "localhost:25565")
  // Only used when protocol is "udp" or "both"
  string udp_target_address = 8;
}

// RegisterResponse is sent by the server to acknowledge tunnel registration.
message RegisterResponse {
  // success indicates whether registration succeeded
  bool success = 1;
  // error_message contains details if success is false
  string error_message = 2;
  // public_url is the publicly accessible URL for this tunnel (e.g., "https://abc123.tunn.to")
  string public_url = 3;
}

// ProxyRequest is sent by the server to instruct the client to open a new
// data connection for forwarding an incoming request.
message ProxyRequest {
  // connection_id uniquely identifies this proxy connection
  string connection_id = 1;
  // source_address is the remote client's address (for logging/debugging)
  string source_address = 2;
}

// ProxyResponse is sent by the client to acknowledge a ProxyRequest.
message ProxyResponse {
  // connection_id matches the ProxyRequest
  string connection_id = 1;
  // success indicates whether the client successfully opened the data connection
  bool success = 2;
  // error_message contains details if success is false
  string error_message = 3;
}

// HealthCheck is a ping message sent by either side to keep the connection alive.
message HealthCheck {
  // timestamp is the sender's current time in Unix milliseconds
  int64 timestamp = 1;
}

// HealthCheckResponse is a pong message sent in response to a HealthCheck.
message HealthCheckResponse {
  // timestamp is the original HealthCheck timestamp (for RTT calculation)
  int64 timestamp = 1;
  // response_timestamp is the responder's current time in Unix milliseconds
  int64 response_timestamp = 2;
}

// HttpRequest is sent by the server to the client with the full HTTP request
// that needs to be proxied to the local target.
message HttpRequest {
  // connection_id uniquely identifies this HTTP request/response pair
  string connection_id = 1;
  // method is the HTTP method (GET, POST, etc.)
  string method = 2;
  // path is the HTTP path (e.g., "/api/users")
  string path = 3;
  // headers is a map of HTTP header names to values
  map<string, string> headers = 4;
  // body is the HTTP request body (may be empty)
  bytes body = 5;
}

// HttpResponse is sent by the client to the server with the HTTP response
// from the local target.
message HttpResponse {
  // connection_id matches the HttpRequest
  string connection_id = 1;
  // status_code is the HTTP status code (e.g., 200, 404)
  int32 status_code = 2;
  // headers is a map of HTTP header names to values
  map<string, string> headers = 3;
  // body is the HTTP response body
  bytes body = 4;
}

// StreamClosed is sent by either side to indicate a connection has closed.
message StreamClosed {
  // connection_id identifies which connection closed
  string connection_id = 1;
  // reason describes why the connection closed (for logging)
  string reason = 2;
}

// UdpPacket is sent bidirectionally to tunnel UDP packets through the gRPC stream.
// The proxy sends packets received from public internet to the serve client.
// The serve client sends response packets from the local UDP target back to the proxy.
message UdpPacket {
  // tunnel_id identifies which tunnel this packet belongs to
  string tunnel_id = 1;
  // source_address is the IP:port of the original UDP sender (for routing responses)
  // Format: "192.168.1.100:12345"
  string source_address = 2;
  // destination_address is the IP:port of the destination (for routing on client side)
  // Format: "localhost:25565"
  string destination_address = 3;
  // data is the raw UDP packet payload
  bytes data = 4;
  // from_client indicates direction: true = from serve client to proxy, false = from proxy to serve client
  bool from_client = 5;
  // timestamp_ms is when the packet was received (Unix milliseconds)
  int64 timestamp_ms = 6;
}
